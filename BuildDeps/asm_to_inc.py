#! python3
"""
Convert commented binary/assembler code to well formatted C byte array.

The input binary/assembler code is expected to be generated by the M$ Visual
Studio C/C++ compiler. Tested & developed using version
'Microsoft Visual Studio 11.0' and the following command-line options:
  /c               - compile, do not link
  /Fa<output-file> - <output-file> = output file name
  /FAsc            - output binary + assembler code

Extracts only code related to one procedure and ignores the rest.

Use the '--help' command-line options for more detailed usage information.

"""

import contextlib
import re
import sys

from argparse import ArgumentParser


__version__ = "1.1"


class ParserError(Exception):
    def __init__(self, msg, line_number):
        Exception.__init__(self, msg)
        self.line_number = line_number


class _UndefinedParam:
    pass


def convert_to_c_array(input_stream, output_stream, proc_name):
    parsed = _parse_asm_code(input_stream, proc_name)
    _CodeArrayPrinter(parsed).print_to(output_stream)


def main(argv=_UndefinedParam):
    proc_name, input_file, output_file = _parse_arguments(argv)
    try:
        with _open_with_default(input_file, "r", sys.stdin) as f_in:
            with _open_with_default(output_file, "w", sys.stdout) as f_out:
                convert_to_c_array(f_in, f_out, proc_name)
    except ParserError as e:
        print("ERROR: line {} - {}".format(e.line_number, e))
        return -2


class _AsmParser:
    STATE_NOT_COLLECTING = 0
    STATE_COLLECTING = 1
    STATE_COLLECTED = 2
    STATE_DONE = 3
    STATE_ERROR = 4

    __rs_code_offset = "([0-9a-fA-F]+)"
    __rs_code = "([0-9a-fA-F]{2}(?: [0-9a-fA-F]{2})*)"
    __rs_code_plus_asm = "\t{}(?:\t+ ?(.*))?$".format(__rs_code)
    __rs_code_line = "  {}{}".format(__rs_code_offset, __rs_code_plus_asm)
    __rs_asm_code_and_comment = "(\S+)\t*(?: ([^\t]*))(?:\t*(;.*))?$"

    __re_code_line = re.compile(__rs_code_line)
    __re_code_line_continued = re.compile(__rs_code_plus_asm)
    __re_asm_code_and_comment = re.compile(__rs_asm_code_and_comment)

    def __init__(self, proc_name):
        rs_decorated = "\S*{}\S*".format(proc_name)
        rs_proc_start = "(({}) PROC)\t+(; {})$".format(rs_decorated, proc_name)
        rs_proc_end = "(({}) ENDP)\t+(; {})$".format(rs_decorated, proc_name)
        self.__re_proc_start = re.compile(rs_proc_start)
        self.__re_proc_end = re.compile(rs_proc_end)

        self.__line_number = 0
        self.__result = []
        self.__partial_code = None
        self.__has_code = False
        self.__expected_offset_value = None
        self.__started_proc_decorated_name = None
        self.__state = self.STATE_NOT_COLLECTING

    def process_input(self, line):
        assert self.__state != self.STATE_DONE
        assert self.__state != self.STATE_ERROR
        self.__line_number += 1
        line = self.__strip_trailing_newline(line)
        if not (self.__match_proc_start(line) or
                self.__match_proc_end(line) or
                self.__state != self.STATE_COLLECTING):
            self.__process_procedure_line(line)

    def final_result(self):
        self.__finalize()
        return self.__result

    def __check_offset(self, offset_value):
        if self.__expected_offset_value is None:
            return
        if self.__expected_offset_value != offset_value:
            self.__parser_error("bad code offset")
        self.__expected_offset_value = None

    def __finalize(self):
        assert self.__state != self.STATE_DONE
        assert self.__state != self.STATE_ERROR
        if self.__state == self.STATE_NOT_COLLECTING:
            self.__parser_error("missing procedure")
        if self.__state != self.STATE_COLLECTED:
            self.__parser_error("procedure incomplete")
        if not self.__has_code:
            self.__parser_error("missing procedure code")
        self.__state = self.STATE_DONE

    def __match_asm_code_and_comment(self, data):
        match = self.__re_asm_code_and_comment.match(data)
        if not match:
            self.__parser_error("could not parse code line comment")
        result = list(match.group(1, 2))  # instruction, args
        comment = match.group(3)
        if comment:
            result.append(comment)
        return result

    def __match_continued_code_line(self, data, partial_code):
        match = self.__re_code_line_continued.match(data)
        if not match:
            self.__parser_error("incomplete code line")
        offset, binary_code = partial_code
        binary_code.extend(match.group(1).split())
        asm_code_and_comment = match.group(2)
        return offset, binary_code, asm_code_and_comment

    def __match_new_code_line(self, data):
        assert self.__partial_code is None
        match = self.__re_code_line.match(data)
        if not match:
            return  # comment
        offset = match.group(1)
        binary_code = match.group(2).split()
        asm_code_and_comment = match.group(3)
        return offset, binary_code, asm_code_and_comment

    def __match_proc_end(self, data):
        match = self.__re_proc_end.match(data)
        if not match:
            return
        if self.__state != self.STATE_COLLECTING:
            self.__parser_error("unexpected ENDP")
        if self.__partial_code is not None:
            self.__parser_error("incomplete code line")
        if self.__started_proc_decorated_name != match.group(2):
            self.__parser_error("decorated PROC/ENDP proc name mismatch")
        self.__state = self.STATE_COLLECTED
        self.__result.append("".join(match.group(1, 3)))
        return True

    def __match_proc_start(self, data):
        match = self.__re_proc_start.match(data)
        if not match:
            return
        if self.__state != self.STATE_NOT_COLLECTING:
            self.__parser_error("multiple procedure start")
        self.__state = self.STATE_COLLECTING
        assert self.__partial_code is None
        assert self.__started_proc_decorated_name is None
        self.__started_proc_decorated_name = match.group(2)
        self.__result.append("".join(match.group(1, 3)))
        return True

    def __parse_code_line(self, line):
        partial_code = self.__partial_code
        self.__partial_code = None
        if partial_code:
            match = self.__match_continued_code_line(line, partial_code)
        else:
            match = self.__match_new_code_line(line)
        if not match:
            return  # acceptable non-code line since matching did not raise
        offset, binary_code, asm_code_and_comment = match
        result = [offset, binary_code]
        if asm_code_and_comment is None:
            return result  # partial code line
        result.extend(self.__match_asm_code_and_comment(asm_code_and_comment))
        return result  # complete code line

    def __parser_error(self, message):
        self.__state = self.STATE_ERROR
        raise ParserError(message, self.__line_number)

    def __process_procedure_code_line(self, parsed_line):
        assert self.__partial_code is None
        offset = parsed_line[0]
        offset_value = int(offset, 16)  # hex string --> numeric value
        self.__check_offset(offset_value)
        if len(parsed_line) < 3:
            self.__partial_code = parsed_line
        else:
            self.__has_code = True
            self.__result.append(parsed_line)
            self.__expected_offset_value = offset_value + len(parsed_line[1])

    def __process_procedure_comment_line(self, line):
        assert self.__partial_code is None
        self.__result.append(line)

    def __process_procedure_line(self, line):
        parsed_code_line = self.__parse_code_line(line)
        if parsed_code_line:
            self.__process_procedure_code_line(parsed_code_line)
        else:
            self.__process_procedure_comment_line(line)

    @staticmethod
    def __strip_trailing_newline(line):
        if line[-1:] == "\n":
            return line[:-1]
        return line


class _CodeArrayPrinter:
    """
    Print parsed code as commented C byte array content.

    All the code lines get an extra trailing comma character except for the
    last one.

    """
    # Code line comments start at a fixed column index calculated based on the
    # longest code line. Note that this means that the extra comma character
    # needs to be taken into consideration when calculating the starting
    # comment column, except when the last code line is strictly longer than
    # any of the other code lines.

    def __init__(self, parsed_code):
        self.__parsed_code = parsed_code
        self.__calculate_output_column_widths()

    def print_to(self, output_stream):
        for i, x in enumerate(self.__parsed_code):
            if isinstance(x, str):
                self.__print_comment(output_stream, x)
            else:
                self.__print_code_line(output_stream, *x,
                    add_trailing_comma=(i != self.__last_code_line))

    def __calculate_output_column_widths(self):
        max_code_len = 0
        last_code_strictly_longest = False
        self.__asm_inst_width = 0
        for i, x in enumerate(self.__parsed_code):
            if not isinstance(x, str):
                self.__last_code_line = i
                code_len = len(x[1])
                last_code_strictly_longest = code_len > max_code_len
                if last_code_strictly_longest:
                    max_code_len = code_len
                asm_inst = x[2]
                if len(asm_inst) > self.__asm_inst_width:
                    self.__asm_inst_width = len(asm_inst)
        self.__code_width = 6 * max_code_len - 2
        if not last_code_strictly_longest:
            self.__code_width += 1  # extra space for a trailing comma

    def __format_code_line(self, offset, code, asm_inst, asm_args,
            asm_comment, add_trailing_comma):
        """Return a formatted code line output string."""
        code_string = ", ".join("0x{}".format(x) for x in code)
        if add_trailing_comma:
            code_string += ","
        assert len(code_string) <= self.__code_width
        if asm_args or asm_comment:
            comment = "{:{}} {}{}".format(asm_inst, self.__asm_inst_width,
                asm_args, asm_comment)
        else:
            comment = asm_inst
        return "{:{}}  // {} - {}".format(code_string, self.__code_width,
            offset, comment)

    def __print_code_line(self, output_stream, offset, code, asm_inst,
            asm_args, asm_comment="", add_trailing_comma=False):
        line = self.__format_code_line(offset, code, asm_inst, asm_args,
            asm_comment, add_trailing_comma)
        print(line, file=output_stream)

    def __print_comment(self, output_stream, text):
        print("// {}".format(text), file=output_stream)


@contextlib.contextmanager
def _open_with_default(name, mode, default):
    """
    Context manager for opening a given file or using a preopened one.

    If the file name is specified as None, a preopened default file is returned
    instead of opening a new one. The preopened file, if used, will not be
    closed on exit.

    """
    need_close = False
    try:
        if name is None:
            file = default
        else:
            file = open(name, mode)
            need_close = True
        yield file
    finally:
        if need_close:
            file.close()


def _parse_arguments(argv):
    parser = ArgumentParser(description="Convert ASM/binary procedure code "
        "output by the Microsoft Visual Studio C/C++ compiler to C/C++ "
        "character array data.")
    parser.add_argument("proc_name", metavar="proc-name", help="procedure "
        "name to extract")
    parser.add_argument("--input-file", help="input file (default: stdin)")
    parser.add_argument("--output-file", help="output file (default: stdout)")
    parser.add_argument("--version", action="version", version=__version__,
        help="print the program version information and exit")
    if argv is _UndefinedParam:
        argv = sys.argv[1:]
    args = parser.parse_args(argv)
    return args.proc_name, args.input_file, args.output_file


def _parse_asm_code(input_stream, proc_name):
    parser = _AsmParser(proc_name)
    for line in input_stream:
        parser.process_input(line)
    return parser.final_result()


if __name__ == "__main__":
    return_code = main()
    if return_code is not None:
        sys.exit(return_code)
