-----------
DistriBuild
-----------

(1.) Motivation.
(2.) Features.
(3.) Trade-offs.
(4.) Requirements.
(5.) Quick-start.
(6.) Design.
(7.) Benchmarks.
(8.) Future development plans.

--------------------------------------------------------------------------------
----------------
(1.) Motivation.
----------------

    DistriBuild is a tool which speeds up build of large C/C++ projects.
    It works by distributing parts of compilation process to other machines on
    the network (i.e. the build farm).
    
    It is inspired by the distcc project. However, DistriBuild's primary
    platform is Windows/Visual C++.

--------------------------------------------------------------------------------
--------------
(2.) Features.
--------------

    Task rejection.
        Server may reject task if it doesn't have enough resources. In this
        case the client will try another farm node. This allows you to run a lot
        of parallel tasks without the danger of suffocating the build farm or
        the local machine.

    Build consistency.
        DistriBuild takes special care that exact same compiler is used both on
        the client and on the server. (more correctly - will soon ;)
        DistriBuild takes special care to preserve compilation environment, so
        that task distribution does not affect the produced objects.
        (more correctly - will soon ;)

    PCH support.
        DistriBuild supports pre-compiled headers. Precompiled headers are
        created locally, on the host machine and are transferred as needed to
        the farm nodes.

    Pump-mode.
        DistriBuild collects all headers required by a source file and transfers
        this data to the farm node. For this part to be done properly,
        DistriBuild has to preprocess source file. For this purpose, Distribuild
        uses (a bit modified) Clang's preprocessor.

    Free.
        DistriBuild is open-source, free and has a permissive license.

--------------------------------------------------------------------------------
----------------
(3.) Trade-offs.
----------------

    * Many farm nodes and PCH.
        * Precompiled headers are usually very large. Transferring them to
          multiple farm nodes may add

    * Small (simple) sources.
        * Simple and small sources are not good candidates for distributed
          compilation - overhead which is added by DistriBuild might cause that
          the overall compilation time increases.

--------------------------------------------------------------------------------
------------------
(4.) Requirements.
------------------

    DistriBuild is written in Python (www.python.org). All machines need to have
    Pyhton installed. DistriBuild works only with Python 3.3+.

    Compiler needs to be installed on all machines on the network.

--------------------------------------------------------------------------------
-----------------
(5.) Quick-start.
-----------------

    ----------------------
    Set up the build farm.
    ----------------------
    
    Place scripts on each of the farm machines. Compilers should already be
    installed. Set hostname and port. Run distribute_server.py.
    
    ----------------------
    Set up client manager.
    ----------------------

    On the client machine you need to set up a manager. Manager keeps track of
    build process global data. It is the entity which contains all information
    about the farm.

    Set up distribute_manager.ini

    Run distribute_manager.py.
    
    You can have multiple managers on the same machine.

    The build environment is now set. Now you need to call the compiler.

    ---------------------
    Calling the compiler.
    ---------------------

    Instead of calling 'cl.exe' you need to call 'msvc.py <manager_id>'. Your
    environment should already be configured for compilation, i.e. you should
    manually call the compiler setup script. msvc.py will try to locate the
    compiler executable on PATH.
    
--------------------------------------------------------------------------------
------------
(6.) Design.
------------

    * Why aren't sources preprocessed on the host machine?
    * Why use Clang?
    * Why use ZeroMQ?
    * Why is there a cache?
    * Is cache optional?

--------------------------------------------------------------------------------
----------------
(7.) Benchmarks.
----------------

    * Currently DistriBuild is mainly tested on building Boost libraries
      (www.boost.org).
        * Boost libraries make heavy use of preprocessor, and are thus an ideal
          candidates for testing both speed and sanity.
    * Building Boost was done with the following command. (Boost.Build was
      modified to use DistriBuild's compiler executable).
        * >>>> bjam stage --stagedir=. -j ## 
    * The host machine was not a farm node in distributed compilation.
    * Boost version tested was 1.54.

    ------------------------------------------------------------
    | type          | parallel # | local   | 2 nodes | 3 nodes |
    ------------------------------------------------------------
    | regular build | 4  tasks   | 7:32.09 |         |         |
    | distributed   | 4  tasks   |         | 8:20.54 | 7:56.79 |
    | distributed   | 16 tasks   |         | 5:07.55 | 4:14.09 |
    | distributed   | 32 tasks   |         | 4:27.89 | 3:57.90 |
    | distributed   | 40 tasks   |         | 4:22.89 | 4:01.11 |
    ------------------------------------------------------------

--------------------------------------------------------------------------------
------------------------------
(8.) Future development plans.
------------------------------

    * Support more platforms.
        * Support GCC on Windows (MinGW).
        * Support GCC on Linux.
        * Support Clang.
        * ...

    * Performance improvement. Currently the client is written in python. Running
      many (30+) of these in parallel chokes the host machine, wasting cycles
      which would be better used in pumping new tasks.
        * Move out all business logic out of client script to manager.
        * Make client as thin as possible.
        * Rewrite client in C++.
        
    * Implement broken (invalid) connection detection using heart-beats.
        * see http://zguide.zeromq.org/page:all#Chapter-Reliable-Request-Reply-Patterns

--------------------------------------------------------------------------------
